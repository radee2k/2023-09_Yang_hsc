---
title: "2023-06_Yang_hsc"
output: github_document
  # html_document:
  #   theme:
  #     bg: "#444444"
  #     fg: "#d6d6d6"
    
date: '2023-06-22'
---

<body style="background-color:FloralWhite;">

___

# Prepare the workign enviornment:

-   install and load packages
-   set %notin% and %notlike%
    -   set ggplot's theme
-   set the working directory
-   set a plan for multithreading

```{r setup, message=FALSE, warning=FALSE}
# install.packages("Seurat")
# install.packages("remotes")
# BiocManager::install(version = '3.16')
# BiocManager::install("glmGamPoi")
# remotes::install_github("stephenturner/annotables")
# install.packages("glmGamPoi")
# BiocManager::install("DESeq2")
# BiocManager::install("MAST") <- Doesn't work
# remotes::install_github("RGLab/MAST")
# install.packages("data.filt")
# remotes::install_github("sonejilab/cellexalvrR") <- Something Yang wanted to try


library(Seurat)
library(dplyr)
library(data.table)
library(Matrix)
library(ggplot2)
library(scales) # to better customize Seurat's plots
library(ggpubr)
library(ggrepel)
library(patchwork)
library(ggbeeswarm) # for better positioning of arrows on log2 change plots - position_jitter doesn't allow to mark points
library(future)
library(annotables) # for turning Ensembl ID to symbol
library(sctransform) # for normalization  
library(glmGamPoi) # for SCTransform
# library(svglite) # for vectorized, lightweight plotting
library(systemfonts) # to set the font for svg outputs
# library(DESeq2)
# library(data.filt) # <---------------- GET IT
library(MAST)
# library(cellexalvrR) <- Something Yang wanted to try

"%notin%" <- Negate("%in%")
"%notlike%" <- Negate("%like%")


# set the theme for plotting (Seurat uses ggplot's themes)
theme_set(new = theme_classic())
theme_update(
  axis.text.x = element_text(vjust = 0.5),
  strip.background = element_rect(fill = '#FFFFFF'),
  plot.title = element_text(hjust = 0.5, size = 25),
  plot.subtitle = element_text(size = 20, hjust = .5),
  axis.title = element_text(size = 23),
  axis.text = element_text(size = 20),
  legend.text = element_text(size = 18),
  legend.key.size = unit(2, 'line'),
  legend.title = element_text(size = 20, hjust = .5, vjust = .5)
  # text = element_text(family= "mono")
)

# That's not necessary (rmarkdown sets its directory as the one the .Rmd file is in.)
wd <- "/disk2/user/radgro/projects/2023-09_Yang_hsc/"
knitr::opts_knit$set(root.dir = wd)

fonts <- list(
  mono = "Consolas",
  sans = "Lato"
)

# set svglite as a default for all the plots
# knitr::opts_chunk$set(knitr.chunk.dev = 'svglite')
# knitr::opts_chunk$set(dev = 'svglite', system_fonts = fonts)
knitr::opts_chunk$set(dev = 'pdf', dev.args = list(system_fonts = fonts),
                       cache.path = "2023-09_Yang_hsc/gfm/", cache = T) # cache of a github_document doesn't work if the path to the gfm folder is not provided!!!

# knitr::opts_chunk$set(cache.extra = 1) # RESETS CACHE

# plan("multicore", workers = 8) # Not allowed on the server
# plan()

```

## Load and prepare the data and metadata.

```{r Load and prepare the data}

p1 <- Read10X("data/A1/count/sample_raw_feature_bc_matrix/")
p1 <- CreateSeuratObject(p1, project = "a")
p2 <- Read10X("data/B1/count/sample_raw_feature_bc_matrix/")
p2 <- CreateSeuratObject(p2, project = "b")
p3 <- Read10X("data/C1/count/sample_raw_feature_bc_matrix/")
p3 <- CreateSeuratObject(p3, project = "c")
p4 <- Read10X("data/D1/count/sample_raw_feature_bc_matrix/")
p4 <- CreateSeuratObject(p4, project = "d")

```


# Merging without integration

```{r, merge_the_objects_without_integration}
hsc_s <- merge(p1, y = p2, project = "2023-09_Yang_hsc")
hsc_s <- merge(hsc_s, y = p3, project = "2023-09_Yang_hsc")
hsc_s <- merge(hsc_s, y = p4, project = "2023-09_Yang_hsc")

rm(list = c("p1", "p2", "p3", "p4"))
suppressMessages(gc())


```



# QC and filtering of cells


## Plotting
### Main QC plots

### Initial removal of empty droplets
```{r qc_with_empty_droplets, fig.width=10, fig.height=5}

VlnPlot(hsc_s, features = c('nCount_RNA','nFeature_RNA'), split.by = "orig.ident", pt.size = 1, raster = F, log = T) +  NoLegend()

```



```{r empty_droplets}
print("nCount_RNA")
length(WhichCells(hsc_s, expression = nCount_RNA > 900))
length(WhichCells(hsc_s, expression = nCount_RNA < 900))


print("nFeature_RNA")
length(WhichCells(hsc_s, expression = nFeature_RNA > 900))
length(WhichCells(hsc_s, expression = nFeature_RNA < 900))

```


```{r empty_droplet_removal}
hsc_s <- subset(x = hsc_s, subset = nCount_RNA > 900 & nFeature_RNA > 900)

```


```{r percentage_features}
hsc_s <- PercentageFeatureSet(hsc_s, pattern = "^MT-", col.name = "percent_mt")
hsc_s <- PercentageFeatureSet(hsc_s, "^RP[SL]", col.name = "percent_ribo")
hsc_s <- PercentageFeatureSet(hsc_s, "^HB[^(P)]", col.name = "percent_hb")
hsc_s <- PercentageFeatureSet(hsc_s, "PECAM1|PF4", col.name = "percent_plat")
```



```{r qc_main, fig.width=10, fig.height=10}
VlnPlot(hsc_s, features = c('nCount_RNA','nFeature_RNA', 'percent_mt', 'percent_hb', "percent_ribo", "percent_plat"), split.by = "orig.ident", pt.size = .5, raster = F) +  NoLegend()

```


```{r feature_filtering}
hsc_s <- subset(x = hsc_s, subset = 100000 > nCount_RNA & percent_mt < 6 & percent_hb < .5 & percent_plat < .5)

```


``` {r umi-features, fig.width = 10, fig.height = 5}
FeatureScatter(hsc_s, "nCount_RNA", "nFeature_RNA", pt.size = 1, plot.cor = T) + scale_x_continuous(labels = scales::scientific) + NoLegend()

```


``` {r most_expressed, fig.width = 10, fig.height = 7}
counts_cells <- hsc_s@assays$RNA@counts
counts_cells <- Matrix::t(Matrix::t(counts_cells)/Matrix::colSums(counts_cells)) * 100

most_expr_cells <- order(apply(counts_cells, 1, median), decreasing = T)[20:1]
most_expr_counts_cells <- as.matrix(t(counts_cells[most_expr_cells,]))

rm(list = c("counts_cells", "most_expr_cells"))
par(mar=c(5, 5, 1, 1))
boxplot(most_expr_counts_cells, cex = 1, las = 1, xlab = "% total count per cell",
        col = (scales::hue_pal())(20)[20:1], horizontal = TRUE)

```

___
# Clustering analysis

## Normalization, scaling and dimensionality reduction
**Normalization was done using the SC transform described here: <https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1874-1> as it is supposed to be depth-independent, which justifies its use in Smartseq3 EV sequencing.**

**During the analysis a change in mapping occurred, without significantly affecting its overall profile, possibly due to package update.**

```{r}
hsc_s <- SCTransform(hsc_s, vst.flavor = "v2", verbose = FALSE) %>%
  RunPCA(npcs = 30, verbose = FALSE) %>%
  RunUMAP(reduction = "pca", dims = 1:30, verbose = FALSE)
  
```

Data allows to stratify cells according to their origin and diagnosis, however different populations seem to be too mixed.

```{r umap_1,  fig.width= 15, fig.height= 10}
DimPlot(hsc_s, group.by = "orig.ident", pt.size = 2)
```


```{r umap_1_split,  fig.width= 15, fig.height= 10}
DimPlot(hsc_s, split.by = "orig.ident", pt.size = 2)
```
```{r top_variable_genes, fig.width= 15, fig.height= 10}
# top variable cells
top_c <- head(VariableFeatures(hsc_s), 20) # No need to use FindVariableFeatures, as SCTransform does that

p_var_c <- VariableFeaturePlot(hsc_s)
LabelPoints(p_var_c, points = top_c, repel = T)
```





```{r feature_plot_top, fig.width= 15, fig.height= 15}
FeaturePlot(hsc_s, features = c("nCount_RNA", "nFeature_RNA", top_c))
```


```{r load_list_of_genes_of_interest}
int_goi <- read.csv2("data/integrin_gene_list_edited.csv", header = F)
# save the list as a vector
int_goi <- int_goi[,1]
```

```{r integrins_of_interest, fig.width= 20, fig.height= 30}
FeaturePlot(hsc_s, features = c("CD34", int_goi))

```


```{r goi_hsc, fig.width= 15, fig.height= 10}
goi_hsc <- c("CD34", "PROM1", "MEIS1", "MLLT3", "RPS27")
FeaturePlot(hsc_s, features = goi_hsc, slot = "scale.data")
FeaturePlot(hsc_s, features = goi_hsc, slot = "counts")

```


```{r goi_lmp, fig.width= 15, fig.height= 15}
goi_lmp <- c( "CD34", "PROM1", "IGLL1", "TOP2A", "MKI67", "HIST1H4C", "RPS27")
FeaturePlot(hsc_s, features = goi_lmp, slot = "scale.data")
FeaturePlot(hsc_s, features = goi_lmp, slot = "counts")
```

```{r xist, fig.width= 15, fig.height= 15}
goi_xist <- c( "CD34", "CD117", "XIST")
FeaturePlot(hsc_s, features = goi_xist, slot = "scale.data")
FeaturePlot(hsc_s, features = goi_xist, slot = "counts")
```

## PCs
**Inspect PCs - Jackstraw doesn't work with SCTransformed data.** 

### Elbow Plot
Around 10 top PCAs should be enough to obtain proper clustering.
```{r,  fig.width= 7, fig.height= 5}
ElbowPlot(hsc_s)
```


## Clustering 


```{r}
hsc_s <- SCTransform(hsc_s, vst.flavor = "v2", verbose = FALSE) %>%
  RunUMAP(reduction = "pca", dims = 1:15, verbose = FALSE)
  
```



```{r clustering_pca, fig.height=10, fig.width=15}
hsc_s <- FindNeighbors(hsc_s, reduction = "pca", verbose = FALSE, dims = 1:15) %>%
  FindClusters(resolution = 0.5, verbose = FALSE, method = "igraph")
```


```{r clustering_plots, fig.height=10, fig.width=15}


alpha_colors_1 <- hue_pal()(4) #  number of colors equal to number of patients - required to change the alpha
alpha_colors_2 <- hue_pal()(10) #  number of colors equal to number of clusters - required to change the alpha


p1 <- DimPlot(hsc_s, group.by = "orig.ident", pt.size = 1, reduction = "umap", cols = alpha(alpha_colors_1, .6)) +
  labs(title = "donor")


p2 <- DimPlot(hsc_s, pt.size = 1, label = T, cols = alpha(alpha_colors_2, .6), reduction = "umap") + 
  labs(title = "cluster") + 
  theme(plot.title = element_text(hjust = .5))


p1 + p2

```



## DE analysis

```{r MAST}
markers_all <- FindAllMarkers(hsc_s, test.use = "MAST", min.pct = 0.6, verbose = T, ) # minimal feature frequency of 60%

for(i in levels(markers_all$cluster)) {print(head(markers_all[markers_all$cluster == i,], 10))}
```

Plot most differentially expressed genes
```{r most_diff_mast, fig.width=15, fig.height=10}
setDT(markers_all)
highest_de <- markers_all[order(avg_log2FC, decreasing = T), .SD[1:5] ,by = cluster][p_val < 5e-2][order(cluster)]
lowest_de <- markers_all[order(avg_log2FC), .SD[1:5] ,by = cluster][p_val < 5e-2][order(cluster)]

most_diff_c <- merge(highest_de, lowest_de, all = T)

markers_all_plot <- markers_all[p_val == 0, p_val := markers_all[p_val != 0, min(p_val)]]
markers_all_plot <- markers_all_plot[gene %like% "DEPRECATED", gene := gsub("DEPRECATED-", "", gene)]

ggplot(markers_all_plot, aes(x = cluster, y = avg_log2FC, color = -log10(p_val))) +
  geom_point(position = position_quasirandom()) +
  geom_text_repel(most_diff_c, mapping = aes(label = gene),
                  size = 4.5, color = "red", fontface = "bold", 
                  force = 5, min.segment.length = .5,
                  segment.size = 1) +
  geom_hline(yintercept = 0) +
  scale_color_continuous(breaks = c(1, 10, 100, 250, 320)) + 
  ggtitle(label = "Fold change and p-values of differentially expressed genes among clusters", 
          subtitle = "most differentially expressed genes are labeled") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 20),
        plot.subtitle = element_text(hjust = 0.5, size = 15))
  
```


```{r cluster_heatmap1,  fig.width= 15, fig.height= 20}
highest_de <- markers_all[order(avg_log2FC, decreasing = T), .SD[1:10] ,by = cluster][p_val < 5e-2][order(cluster)]


DoHeatmap(hsc_s, group.by = "seurat_clusters", features = highest_de$gene, angle = 0, hjust = .5) + 
  NoLegend() + 
  ggtitle(label = "Expression of top markers of clusters of cells found in the dataset")

```



```{r, eval = F}
# for(i in levels(markers_all$cluster)) {print(head(markers_all[markers_all$cluster == i,], 30))}

knitr::kable(markers_all[gene %in% int_goi][,c(1, 2, 6, 7)], caption = "**Differentially expressen integrins**", 
             align = "c", digits = 2)

```


```{r, fig.width=10, fig.height=10}

list_int_de <- unique(markers_all[gene %in% int_goi][,gene])

p1 <- FeaturePlot(hsc_s, features = list_int_de)
p2 <- DimPlot(hsc_s, label = T)

p1 + p2


```





```{r cell_cycle}


CellCycleScoring


```

